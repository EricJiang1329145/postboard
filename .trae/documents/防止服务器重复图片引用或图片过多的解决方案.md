## 问题分析

当前的图片存储机制存在以下问题：
1. 每次上传图片都会生成新的文件名，即使是完全相同的图片
2. 没有检测重复图片的机制，导致相同图片被多次存储
3. 没有清理机制，未使用的图片会一直占用存储空间
4. 没有图片引用计数，无法知道哪些图片被使用

## 解决方案

### 1. 图片哈希检测
- **实现方式**：计算上传图片的MD5/SHA-1哈希值，作为图片的唯一标识符
- **存储策略**：
  - 创建图片元数据表格，记录图片哈希、文件名、URL、上传时间等信息
  - 上传前检查哈希值是否已存在，若存在则返回现有图片URL
  - 若不存在则存储新图片并更新元数据

### 2. 图片引用计数
- **实现方式**：
  - 在图片元数据表格中添加`referenceCount`字段
  - 当公告创建或更新时，解析内容中的图片URL，更新引用计数
  - 当公告删除时，减少引用的图片计数

### 3. 定期清理机制
- **实现方式**：
  - 定时任务（如每天凌晨）扫描数据库
  - 找出`referenceCount`为0且超过一定时间（如30天）的图片
  - 删除这些图片文件并从元数据表格中移除

### 4. 图片优化
- **实现方式**：
  - 在上传时自动压缩图片，设置最大分辨率
  - 转换为更高效的图片格式（如WebP）
  - 支持根据设备尺寸动态加载不同分辨率的图片

### 5. 上传限制
- **实现方式**：
  - 限制单张图片大小（当前已实现5MB限制）
  - 限制每个公告的图片数量
  - 限制每天的上传总量

## 技术实现细节

### 1. 数据库设计
```sql
-- 创建图片元数据表
CREATE TABLE IF NOT EXISTS images (
  id TEXT PRIMARY KEY,
  hash TEXT UNIQUE NOT NULL, -- 图片哈希值，用于检测重复
  filename TEXT NOT NULL, -- 存储的文件名
  url TEXT NOT NULL, -- 访问URL
  referenceCount INTEGER DEFAULT 0, -- 引用计数
  createdAt TEXT NOT NULL, -- 上传时间
  updatedAt TEXT NOT NULL, -- 更新时间
  size INTEGER NOT NULL -- 图片大小（字节）
);
```

### 2. 图片上传流程优化
```javascript
// 1. 计算图片哈希
const fs = require('fs');
const crypto = require('crypto');

const calculateHash = (filePath) => {
  return new Promise((resolve, reject) => {
    const hash = crypto.createHash('md5');
    const stream = fs.createReadStream(filePath);
    
    stream.on('error', reject);
    stream.on('data', (chunk) => hash.update(chunk));
    stream.on('end', () => resolve(hash.digest('hex')));
  });
};

// 2. 检查重复图片
app.post('/api/upload', upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: '没有上传文件' });
    }
    
    // 计算图片哈希
    const hash = await calculateHash(req.file.path);
    
    // 检查哈希是否已存在
    const existingImage = await db.get('SELECT * FROM images WHERE hash = ?', [hash]);
    
    if (existingImage) {
      // 重复图片，删除临时文件，返回已有URL
      fs.unlinkSync(req.file.path);
      return res.json({ 
        success: true, 
        url: existingImage.url,
        filename: existingImage.filename 
      });
    }
    
    // 新图片，保存到数据库
    const imageUrl = `${req.protocol}://${req.get('host')}/uploads/${req.file.filename}`;
    const createdAt = new Date().toISOString();
    const id = generateId();
    
    await db.run(
      `INSERT INTO images (id, hash, filename, url, referenceCount, createdAt, updatedAt, size) 
       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
      [id, hash, req.file.filename, imageUrl, 0, createdAt, createdAt, req.file.size]
    );
    
    res.json({ 
      success: true, 
      url: imageUrl,
      filename: req.file.filename 
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 3. 引用计数管理
- **创建/更新公告时**：解析内容中的图片URL，为每个URL对应的图片增加引用计数
- **删除公告时**：解析内容中的图片URL，为每个URL对应的图片减少引用计数

### 4. 定期清理任务
```javascript
// 定期清理未使用的图片（每天凌晨2点执行）
const schedule = require('node-schedule');

// 每天凌晨2点执行清理任务
schedule.scheduleJob('0 2 * * *', async () => {
  try {
    console.log('开始清理未使用的图片...');
    
    // 查找引用计数为0且超过30天的图片
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
    const unusedImages = await db.all(
      `SELECT * FROM images WHERE referenceCount = 0 AND createdAt < ?`,
      [thirtyDaysAgo]
    );
    
    for (const image of unusedImages) {
      // 删除图片文件
      const filePath = path.join(uploadsDir, image.filename);
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
      
      // 从数据库中移除
      await db.run(`DELETE FROM images WHERE id = ?`, [image.id]);
    }
    
    console.log(`清理完成，共删除 ${unusedImages.length} 张未使用的图片`);
  } catch (error) {
    console.error('清理图片失败:', error.message);
  }
});
```

## 预期效果

1. **节省存储空间**：相同图片只存储一次，避免重复存储
2. **提高上传效率**：重复图片直接返回已有URL，无需重新上传
3. **自动清理垃圾**：定期清理未使用的图片，释放存储空间
4. **优化资源管理**：通过引用计数了解图片使用情况
5. **增强系统稳定性**：避免存储空间被无限占用

## 实现步骤

1. 修改数据库结构，创建图片元数据表
2. 实现图片哈希计算和重复检测功能
3. 实现图片引用计数管理
4. 实现定期清理任务
5. 优化图片上传API，支持重复图片检测
6. 测试所有功能，确保正常运行

## 注意事项

1. **哈希碰撞**：虽然概率极低，但需考虑哈希碰撞的可能性，可使用双哈希（MD5+SHA-1）提高安全性
2. **性能影响**：哈希计算会增加上传时间，可考虑在后台异步处理
3. **数据一致性**：确保引用计数的准确性，避免并发更新问题
4. **备份策略**：定期备份图片元数据，防止数据丢失
5. **兼容性**：确保现有图片能平滑迁移到新系统